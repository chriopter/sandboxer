<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>{{session_title}} - sandboxer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <link rel="stylesheet" href="/static/style.css">
  <link rel="stylesheet" href="/static/vendor/xterm.min.css">
  <link rel="icon" href="/static/favicon.png">
</head>
<body class="terminal-page">
  <div class="header">
    <span>{{title_html}}</span>
    <div class="spacer"></div>
    <button id="upload-btn" title="Upload file">ðŸ“Ž</button>
    <button class="btn-teal" id="ssh-btn">ssh</button>
    <button class="btn-red" id="kill-btn">Ã—</button>
  </div>
  <div class="terminal-wrap">
    <div id="terminal-container"></div>
  </div>
  <div id="toast"></div>
  <script>window.SESSION = "{{session_name}}";</script>
  <script src="/static/vendor/xterm.min.js"></script>
  <script src="/static/vendor/addon-fit.min.js"></script>
  <script src="/static/vendor/addon-webgl.min.js"></script>
  <script>
    const THEME = {
      background: "#1e1e2e", foreground: "#cdd6f4", cursor: "#f5e0dc",
      black: "#45475a", red: "#f38ba8", green: "#a6e3a1", yellow: "#f9e2af",
      blue: "#89b4fa", magenta: "#f5c2e7", cyan: "#94e2d5", white: "#bac2de",
    };

    let ws, term, fit;

    function init() {
      const container = document.getElementById("terminal-container");
      term = new Terminal({ cursorBlink: true, fontSize: 14, theme: THEME });
      fit = new FitAddon.FitAddon();
      term.loadAddon(fit);
      try { term.loadAddon(new WebglAddon.WebglAddon()); } catch {}
      term.open(container);
      setTimeout(() => { fit.fit(); connect(); }, 50);

      window.addEventListener("resize", () => fit.fit());
      term.onData((d) => ws?.send(d));
      term.onResize(({ rows, cols }) => ws?.send(JSON.stringify({ action: "resize", rows, cols })));
    }

    function connect() {
      const proto = location.protocol === "https:" ? "wss:" : "ws:";
      ws = new WebSocket(`${proto}//${location.host}/ws/terminal`);
      ws.binaryType = "arraybuffer";

      ws.onopen = () => ws.send(JSON.stringify({ action: "attach", session: SESSION, rows: term.rows, cols: term.cols }));
      ws.onmessage = (e) => {
        if (typeof e.data === "string") { try { JSON.parse(e.data); } catch { term.write(e.data); } }
        else term.write(new Uint8Array(e.data));
      };
      ws.onclose = () => setTimeout(connect, 1000);
    }

    function toast(msg) {
      const t = document.getElementById("toast");
      t.textContent = msg; t.classList.add("show");
      setTimeout(() => t.classList.remove("show"), 2000);
    }

    function copyToClipboard(text) {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text).then(() => toast("Copied: " + text.substring(0, 50))).catch(() => fallbackCopy(text));
      } else {
        fallbackCopy(text);
      }
    }

    function fallbackCopy(text) {
      const ta = document.createElement("textarea");
      ta.value = text;
      ta.style.position = "fixed";
      ta.style.left = "-9999px";
      document.body.appendChild(ta);
      ta.select();
      try { document.execCommand("copy"); toast("Copied: " + text.substring(0, 50)); }
      catch { toast("Copy failed"); }
      document.body.removeChild(ta);
    }

    document.getElementById("ssh-btn").onclick = () => {
      copyToClipboard(`ssh -t sandboxer@${location.hostname} sudo tmux attach -t '${SESSION}'`);
    };

    document.getElementById("kill-btn").onclick = async () => {
      if (confirm("Kill session?")) { await fetch(`/kill?session=${encodeURIComponent(SESSION)}`); location.href = "/"; }
    };

    async function doUpload(file) {
      toast("Uploading...");
      const reader = new FileReader();
      reader.onload = async () => {
        const base64 = reader.result.split(",")[1];
        try {
          const res = await fetch("/api/upload", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ filename: file.name, content: base64 })
          });
          const data = await res.json();
          if (data.ok && data.path) {
            ws?.send(data.path + " ");
            toast("Uploaded: " + data.path);
          } else {
            toast("Upload failed");
          }
        } catch { toast("Upload error"); }
      };
      reader.readAsDataURL(file);
    }

    document.getElementById("upload-btn").onclick = () => {
      const input = document.createElement("input");
      input.type = "file";
      input.onchange = () => {
        const file = input.files[0];
        if (file) doUpload(file);
      };
      input.click();
    };

    document.addEventListener("paste", (e) => {
      const items = e.clipboardData?.items;
      if (!items || items.length === 0) return;
      for (const item of items) {
        if (item.kind === "file") {
          const file = item.getAsFile();
          if (file) {
            e.preventDefault();
            e.stopPropagation();
            let filename = file.name;
            if (!filename || filename === "image.png" || filename === "blob") {
              const ext = file.type.split("/")[1] || "png";
              filename = `paste-${Date.now()}.${ext}`;
            }
            const namedFile = new File([file], filename, { type: file.type });
            doUpload(namedFile);
            return;
          }
        }
      }
    }, true);

    init();
  </script>
</body>
</html>
