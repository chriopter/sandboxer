#!/bin/bash
# sandboxer-shell - Interactive session picker for SSH takeover
# Install: sudo ln -sf /home/sandboxer/sandboxer-repo/sandboxer-shell /usr/local/bin/sandboxer-shell
# Usage:
#   ssh -t sandboxer@host sandboxer-shell                    # folder picker → session picker
#   ssh -t sandboxer@host sandboxer-shell SESSION            # attach directly
#   ssh -t sandboxer@host sandboxer-shell -f /path           # skip folder picker, filter by path
#   ssh -t sandboxer@host sandboxer-shell --all              # skip folder picker, show all
#
# Multi-select: Use TAB/Shift-TAB to select multiple sessions, creates split panes
# Create sessions: c=Claude, l=Lazygit, b=Bash, g=Gemini (requires folder context)
# Navigation: ESC to go back to folder picker

set -e

# Use sudo for tmux since sessions run as root
TMUX_CMD="sudo tmux"
WORKDIRS_FILE="/etc/sandboxer/session_workdirs.json"

# Parse arguments
FOLDER_FILTER=""
SKIP_FOLDER_PICKER=false

while [[ $# -gt 0 ]]; do
    case "$1" in
        -f|--folder)
            FOLDER_FILTER="$2"
            SKIP_FOLDER_PICKER=true
            shift 2
            ;;
        --all)
            SKIP_FOLDER_PICKER=true
            shift
            ;;
        *)
            # Direct attach mode if session name provided
            session="$1"
            if $TMUX_CMD has-session -t "$session" 2>/dev/null; then
                exec $TMUX_CMD attach -t "$session"
            else
                echo "Session '$session' not found"
                exec bash
            fi
            ;;
    esac
done

# Get workdir for a session from JSON
get_workdir() {
    local name="$1"
    if [ -f "$WORKDIRS_FILE" ]; then
        python3 -c "import json; d=json.load(open('$WORKDIRS_FILE')); print(d.get('$name', ''))" 2>/dev/null || echo ""
    fi
}

# Get unique folders from workdirs
get_folders() {
    if [ -f "$WORKDIRS_FILE" ]; then
        python3 -c "
import json
try:
    d = json.load(open('$WORKDIRS_FILE'))
    folders = sorted(set(d.values()))
    for f in folders:
        print(f)
except: pass
" 2>/dev/null
    fi
}

# Colors (Catppuccin Mocha)
MAUVE=$'\033[38;2;203;166;247m'
GREEN=$'\033[38;2;166;227;161m'
RESET=$'\033[0m'

get_sessions() {
    $TMUX_CMD list-sessions -F "#{session_name}" 2>/dev/null || true
}

format_session() {
    local name="$1"
    local created=$($TMUX_CMD display-message -t "$name" -p "#{session_created}" 2>/dev/null || echo "0")
    local attached=$($TMUX_CMD display-message -t "$name" -p "#{session_attached}" 2>/dev/null || echo "0")
    local title=$($TMUX_CMD display-message -t "$name" -p "#{pane_title}" 2>/dev/null || echo "")
    local workdir=$(get_workdir "$name")

    # Time ago
    local now=$(date +%s)
    local diff=$((now - created))
    local time_ago
    if [ $diff -lt 60 ]; then
        time_ago="now"
    elif [ $diff -lt 3600 ]; then
        time_ago="$((diff / 60))m"
    elif [ $diff -lt 86400 ]; then
        time_ago="$((diff / 3600))h"
    else
        time_ago="$((diff / 86400))d"
    fi

    # Status indicator
    local status="  "
    [ "$attached" = "1" ] && status="● "

    # Clean title
    [[ "$title" == *"✳"* ]] && title="${title#*✳ }"

    # Short folder name (basename or "?" if unknown)
    local folder_short="?"
    if [ -n "$workdir" ]; then
        folder_short=$(basename "$workdir")
        [ "$folder_short" = "/" ] && folder_short="/"
    fi

    if [ -n "$title" ] && [ "$title" != "Window Title" ] && [ "$title" != "$name" ]; then
        echo "$status[$folder_short] $title ($name) [$time_ago]"
    else
        echo "$status[$folder_short] $name [$time_ago]"
    fi
}

# Build session list for fzf (optionally filtered by folder)
build_session_list() {
    local folder_filter="$1"
    local sessions_raw=$(get_sessions)

    while read -r name; do
        [ -z "$name" ] && continue
        # Skip SSH takeover wrapper sessions
        [[ "$name" == split-* ]] && continue

        # Filter by folder if specified
        if [ -n "$folder_filter" ]; then
            local workdir=$(get_workdir "$name")
            if [ "$workdir" != "$folder_filter" ] && [[ "$workdir" != "$folder_filter/"* ]]; then
                continue
            fi
        fi

        echo "$(format_session "$name")|$name"
    done <<< "$sessions_raw"
}

create_split_session() {
    local sessions=("$@")
    local count=${#sessions[@]}
    local split_name="split-$(date +%s)"

    # Create new session with first selection
    unset TMUX
    $TMUX_CMD new-session -d -s "$split_name"
    $TMUX_CMD send-keys -t "$split_name" "unset TMUX && sudo tmux attach -t '${sessions[0]}'" Enter

    # Add panes for remaining sessions
    for ((i=1; i<count; i++)); do
        $TMUX_CMD split-window -t "$split_name"
        $TMUX_CMD send-keys -t "$split_name" "unset TMUX && sudo tmux attach -t '${sessions[$i]}'" Enter
        $TMUX_CMD select-layout -t "$split_name" tiled
    done

    $TMUX_CMD set -t "$split_name" mouse on
    exec $TMUX_CMD attach -t "$split_name"
}

# Create a new session directly with tmux (bypasses API auth)
create_session() {
    local type="$1"
    local folder="$2"

    if [ -z "$folder" ] || [ "$folder" = "/" ]; then
        return 1
    fi

    # Generate session name: folder-type-N
    local dir_name=$(basename "$folder" | tr '.' '_')
    local prefix="${dir_name}-${type}-"

    # Find next number
    local max_num=0
    while read -r name; do
        if [[ "$name" == ${prefix}* ]]; then
            local num="${name#$prefix}"
            if [[ "$num" =~ ^[0-9]+$ ]] && [ "$num" -gt "$max_num" ]; then
                max_num="$num"
            fi
        fi
    done < <($TMUX_CMD list-sessions -F "#{session_name}" 2>/dev/null)

    local session_name="${prefix}$((max_num + 1))"

    # Create tmux session
    $TMUX_CMD new-session -d -s "$session_name" -c "$folder"
    $TMUX_CMD set -t "$session_name" mouse on

    # Start the appropriate command
    case "$type" in
        claude)
            local cmd="IS_SANDBOX=1 claude --dangerously-skip-permissions --system-prompt /home/sandboxer/git/sandboxer/system-prompt.txt"
            $TMUX_CMD send-keys -t "$session_name" "$cmd" Enter
            ;;
        lazygit)
            $TMUX_CMD send-keys -t "$session_name" "lazygit" Enter
            ;;
        gemini)
            $TMUX_CMD send-keys -t "$session_name" "gemini" Enter
            ;;
        # bash: just leave shell prompt
    esac

    # Save workdir to JSON for sandboxer to pick up (needs sudo for /etc/sandboxer)
    sudo python3 -c "
import json, os
os.makedirs('/etc/sandboxer', exist_ok=True)
for fname in ['session_workdirs.json', 'session_meta.json']:
    f = '/etc/sandboxer/' + fname
    d = {}
    if os.path.exists(f):
        try: d = json.load(open(f))
        except: pass
    if fname == 'session_workdirs.json':
        d['$session_name'] = '$folder'
    else:
        d['$session_name'] = {'workdir': '$folder', 'type': '$type', 'mode': 'cli'}
    json.dump(d, open(f, 'w'))
"

    echo "$session_name"
}

pick_folder() {
    local folders=$(get_folders)
    if [ -z "$folders" ]; then
        echo ""
        return 1
    fi

    # Add "all" option at the top
    local fzf_input="[all folders]"$'\n'"$folders"

    local selected
    selected=$(printf '%s' "$fzf_input" | fzf \
        --height=40% \
        --reverse \
        --border=rounded \
        --border-label=" folder " \
        --border-label-pos=3 \
        --prompt="› " \
        --pointer="▶" \
        --header="Select folder context (ESC to exit)" \
        --color="fg:#cdd6f4,bg:#1e1e2e,hl:#f38ba8" \
        --color="fg+:#cdd6f4,bg+:#313244,hl+:#f38ba8" \
        --color="info:#94e2d5,prompt:#cba6f7,pointer:#f5e0dc" \
        --color="marker:#a6e3a1,spinner:#f5e0dc,header:#6c7086" \
        --color="border:#6c7086,label:#cba6f7" \
        --expect="esc" \
        2>/dev/null)

    local key=$(echo "$selected" | head -1)
    local choice=$(echo "$selected" | tail -1)

    if [ "$key" = "esc" ] || [ -z "$choice" ]; then
        echo "__EXIT__"
        return 0
    fi

    if [ "$choice" = "[all folders]" ]; then
        echo ""
    else
        echo "$choice"
    fi
}

pick_session() {
    local folder_filter="$1"

    # Build header with folder info and shortcuts
    local header="TAB: multi │ ENTER: attach │ ESC: back"
    local create_hint=""
    if [ -n "$folder_filter" ]; then
        header="$folder_filter"
        create_hint="c:claude  l:lazygit  b:bash  g:gemini"
    fi

    # Export for reload command
    export SANDBOXER_FOLDER_FILTER="$folder_filter"
    export SANDBOXER_HINT="$create_hint"

    # Simple reload command - just run the helper script directly
    local reload_cmd="/home/sandboxer/git/sandboxer/sandboxer-shell-funcs"

    # Build initial input
    local fzf_input=$(build_session_list "$folder_filter")
    [ -n "$create_hint" ] && fzf_input="$create_hint"$'\n'"$fzf_input"

    # Prepare fzf options with live reload every 2 seconds
    local fzf_opts=(
        --multi
        --delimiter='|'
        --with-nth=1
        --height=50%
        --reverse
        --border=rounded
        --border-label=" sandboxer "
        --border-label-pos=3
        --prompt="› "
        --pointer="▶"
        --marker="✓"
        --header="$header"
        --color="fg:#cdd6f4,bg:#1e1e2e,hl:#f38ba8"
        --color="fg+:#cdd6f4,bg+:#313244,hl+:#f38ba8"
        --color="info:#94e2d5,prompt:#cba6f7,pointer:#f5e0dc"
        --color="marker:#a6e3a1,spinner:#f5e0dc,header:#6c7086"
        --color="border:#6c7086,label:#cba6f7"
        --expect="esc,c,l,b,g"
        --bind="ctrl-r:reload:$reload_cmd"
    )

    local selected
    selected=$(printf '%s' "$fzf_input" | fzf "${fzf_opts[@]}" 2>/dev/null) || true

    # Parse result
    local key=$(echo "$selected" | head -1)
    local choices=$(echo "$selected" | tail -n +2)

    # Handle special keys
    case "$key" in
        esc)
            echo "__BACK__"
            return 0
            ;;
        c|l|b|g)
            if [ -n "$folder_filter" ]; then
                local type_map="c:claude l:lazygit b:bash g:gemini"
                local session_type=$(echo "$type_map" | tr ' ' '\n' | grep "^$key:" | cut -d: -f2)
                local new_session=$(create_session "$session_type" "$folder_filter")
                if [ -n "$new_session" ]; then
                    echo "$new_session"
                    return 0
                fi
            fi
            echo "__BACK__"
            return 0
            ;;
    esac

    # Extract session names from selection
    local session_names=()
    while read -r line; do
        [ -z "$line" ] && continue
        # Skip the hint line
        [[ "$line" == *"claude"*"lazygit"*"bash"* ]] && continue
        session_names+=("${line##*|}")
    done <<< "$choices"

    if [ ${#session_names[@]} -eq 0 ]; then
        echo "__EXIT__"
        return 0
    elif [ ${#session_names[@]} -eq 1 ]; then
        echo "${session_names[0]}"
    else
        # Multiple sessions - return special marker
        echo "__SPLIT__:${session_names[*]}"
    fi
}

main() {
    while true; do
        # Show folder picker by default (unless -f or --all specified)
        if [ "$SKIP_FOLDER_PICKER" = false ]; then
            FOLDER_FILTER=$(pick_folder)
            if [ "$FOLDER_FILTER" = "__EXIT__" ]; then
                exit 0
            fi
        fi

        # Reset skip flag after first use (allows ESC to return to folder picker)
        local was_skipped=$SKIP_FOLDER_PICKER
        SKIP_FOLDER_PICKER=false

        # Check if any sessions exist
        local sessions_raw=$(get_sessions)
        local has_sessions=false
        while read -r name; do
            [ -z "$name" ] && continue
            [[ "$name" == split-* ]] && continue

            if [ -z "$FOLDER_FILTER" ]; then
                has_sessions=true
                break
            fi

            local workdir=$(get_workdir "$name")
            if [ "$workdir" = "$FOLDER_FILTER" ] || [[ "$workdir" == "$FOLDER_FILTER/"* ]]; then
                has_sessions=true
                break
            fi
        done <<< "$sessions_raw"

        if [ "$has_sessions" = false ]; then
            if [ -n "$FOLDER_FILTER" ]; then
                echo -e "${MAUVE}No sessions in: $FOLDER_FILTER${RESET}"
                echo -e "${GREEN}Press c/l/b/g to create a session, or wait...${RESET}"
                # Show empty picker to allow creating sessions
                local result=$(pick_session "$FOLDER_FILTER")
                case "$result" in
                    __BACK__)
                        continue
                        ;;
                    __EXIT__)
                        if [ "$was_skipped" = true ]; then
                            exec bash -l
                        fi
                        continue
                        ;;
                    *)
                        if [ -n "$result" ]; then
                            exec $TMUX_CMD attach -t "$result"
                        fi
                        continue
                        ;;
                esac
            else
                echo -e "${MAUVE}No active sessions${RESET}"
                exec bash -l
            fi
        fi

        # Pick session
        local result=$(pick_session "$FOLDER_FILTER")

        case "$result" in
            __BACK__)
                if [ "$was_skipped" = true ]; then
                    # Was started with -f or --all, go to folder picker now
                    continue
                fi
                continue
                ;;
            __EXIT__)
                if [ "$was_skipped" = true ]; then
                    exec bash -l
                fi
                exit 0
                ;;
            __SPLIT__:*)
                # Multiple sessions selected
                local sessions_str="${result#__SPLIT__:}"
                read -ra session_names <<< "$sessions_str"
                create_split_session "${session_names[@]}"
                ;;
            *)
                if [ -n "$result" ]; then
                    exec $TMUX_CMD attach -t "$result"
                fi
                ;;
        esac
    done
}

main
