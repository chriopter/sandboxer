#!/bin/bash
# claude-loop - Autonomous Claude loop with split-pane monitor

SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
SYSTEM_PROMPT="$SCRIPT_DIR/system-prompt.txt"
MONITOR_SCRIPT="$SCRIPT_DIR/claude-loop-monitor"
ACTIVITY_TIMEOUT=900  # 15 minutes in seconds
STATUS_FILE="/tmp/claude-loop-status-$$"
WORKDIR="$(pwd)"

LOOP_PROMPT='You are in AUTONOMOUS LOOP MODE.

A PROMPT.md file exists in your working directory with your task. Work on it.

## Progress tracking (CRITICAL):
- Check off items with [x] IMMEDIATELY after completing each one
- Update PROMPT.md frequently - this is how the next agent knows what is done
- Your checked-off items are the handoff to the next instance

## Exiting (do this freely):
- Run /exit anytime - context full, stuck, or just need fresh start
- The loop restarts automatically and a new agent continues your work
- Exiting is normal and expected - do not hesitate to exit
- The next agent reads PROMPT.md and sees your [x] checked items

## ONLY mark as done when 100% complete:
- ONLY run "mv PROMPT.md PROMPT.done.md" if EVERY SINGLE task is finished
- If ANY unchecked items remain, DO NOT rename - just /exit
- Double-check all boxes are [x] before renaming
- When in doubt, just /exit - do not rename

## If fully blocked:
1. Add "## Blocked" section explaining why
2. Run: mv PROMPT.md PROMPT.blocked.md

## Important:
- Read PROMPT.md first - see what is already [x] checked
- Check git log for previous work
- Work autonomously - make decisions, do not ask questions
- Commit regularly with descriptive messages'

# Check for PROMPT.md
if [ ! -f PROMPT.md ]; then
  echo "No PROMPT.md found in current directory."
  echo "Create one with your task description, then run claude-loop again."
  exit 1
fi

# Write runner script (the main loop logic)
RUNNER_SCRIPT="/tmp/claude-loop-runner-$$.sh"
cat > "$RUNNER_SCRIPT" << 'RUNNER_EOF'
#!/bin/bash
STATUS_FILE="$1"
SYSTEM_PROMPT="$2"
ACTIVITY_TIMEOUT="$3"
LOOP_PROMPT="$4"

# Initialize status
cat > "$STATUS_FILE" << EOF
iteration=0
start_time=$(date +%s)
last_activity=$(date +%s)
status=starting
EOF

update_status() {
  sed -i "s/^$1=.*/$1=$2/" "$STATUS_FILE" 2>/dev/null || echo "$1=$2" >> "$STATUS_FILE"
}

iteration=0
while [ -f PROMPT.md ]; do
  ((iteration++))
  update_status "iteration" "$iteration"
  update_status "status" "running"
  update_status "last_activity" "$(date +%s)"

  echo ""
  echo "══════════════════════════════════════════════════════"
  echo "  Iteration $iteration | $(date '+%Y-%m-%d %H:%M:%S')"
  echo "══════════════════════════════════════════════════════"
  echo ""

  marker=$(mktemp)
  touch "$marker"
  no_activity=0

  update_status "status" "claude_running"

  # Run Claude in background so we can monitor and kill if idle
  echo "Read PROMPT.md and work on the tasks. Check off each item with [x] as you complete it." | IS_SANDBOX=1 claude --dangerously-skip-permissions --system-prompt "$SYSTEM_PROMPT" --append-system-prompt "$LOOP_PROMPT" &
  claude_pid=$!

  # Background activity tracker - kills Claude if idle too long
  (
    while kill -0 $claude_pid 2>/dev/null; do
      sleep 30

      # Check for any file changes (excluding .git)
      if find . -type f -newer "$marker" ! -path './.git/*' 2>/dev/null | grep -q .; then
        touch "$marker"
        update_status "last_activity" "$(date +%s)"
      fi

      # Check if idle for too long
      source "$STATUS_FILE"
      now=$(date +%s)
      idle_time=$((now - last_activity))

      if [ $idle_time -ge $ACTIVITY_TIMEOUT ]; then
        update_status "status" "idle_restart"
        echo ""
        echo "──── No activity for 15min, restarting Claude... ────"
        kill $claude_pid 2>/dev/null
        sleep 2
        kill -9 $claude_pid 2>/dev/null
        break
      fi
    done
  ) &
  tracker_pid=$!

  # Wait for Claude to exit (either naturally or killed by tracker)
  wait $claude_pid 2>/dev/null

  # Cleanup
  rm -f "$marker"
  kill $tracker_pid 2>/dev/null

  if [ -f PROMPT.md ]; then
    update_status "status" "restarting"
    echo ""
    echo "──── Claude exited, restarting in 3s... ────"
    sleep 3
  fi
done

update_status "status" "complete"
echo ""
echo "══════════════════════════════════════════════════════"
echo "  Loop stopped - PROMPT.md removed or renamed"
[ -f PROMPT.blocked.md ] && echo "  Task blocked: PROMPT.blocked.md"
echo "  Check PROMPT.md for completed items"
echo "══════════════════════════════════════════════════════"
sleep 30
rm -f "$STATUS_FILE"
RUNNER_EOF
chmod +x "$RUNNER_SCRIPT"

# Check if we're already inside tmux (sandboxer session)
if [ -n "$TMUX" ]; then
  # Inside sandboxer: split current pane, don't create new session

  # Split right for monitor
  tmux split-window -h -l 42 "$MONITOR_SCRIPT '$STATUS_FILE' '$WORKDIR'"

  # Select left pane and run loop
  tmux select-pane -L
  exec "$RUNNER_SCRIPT" "$STATUS_FILE" "$SYSTEM_PROMPT" "$ACTIVITY_TIMEOUT" "$LOOP_PROMPT"
else
  # Standalone: create new tmux session
  SESSION_NAME="claude-loop-$$"

  tmux new-session -d -s "$SESSION_NAME" -c "$WORKDIR"
  tmux send-keys -t "$SESSION_NAME" "$RUNNER_SCRIPT '$STATUS_FILE' '$SYSTEM_PROMPT' '$ACTIVITY_TIMEOUT' '$LOOP_PROMPT'" Enter

  # Split and run monitor
  tmux split-window -t "$SESSION_NAME" -h -l 42
  tmux send-keys -t "$SESSION_NAME" "$MONITOR_SCRIPT '$STATUS_FILE' '$WORKDIR'" Enter

  # Select left pane
  tmux select-pane -t "$SESSION_NAME":0.0

  # Attach
  tmux attach-session -t "$SESSION_NAME"
fi
