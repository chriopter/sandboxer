#!/bin/bash
# claude-loop - Autonomous Claude loop with split-pane monitor

SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
SYSTEM_PROMPT="$SCRIPT_DIR/system-prompt.txt"
MONITOR_SCRIPT="$SCRIPT_DIR/claude-loop-monitor"
ACTIVITY_TIMEOUT=60
STATUS_FILE="/tmp/claude-loop-status-$$"
WORKDIR="$(pwd)"

LOOP_PROMPT='You are in AUTONOMOUS LOOP MODE.

A PROMPT.md file exists in your working directory with your task. Work on it.

## When you complete the task:
1. Add a "## Results" section to PROMPT.md documenting what you did
2. Run: mv PROMPT.md PROMPT.done.md
3. Run: /exit

This signals the loop to stop. The /exit command is REQUIRED after moving the file.

## If you hit context limits or need to continue later:
Run /exit to exit. The loop will restart you with fresh context.
Your previous work is saved in files/git - check git log and project state.

## If you are blocked and cannot proceed:
1. Add a "## Blocked" section explaining why
2. Run: mv PROMPT.md PROMPT.blocked.md
3. Run: /exit

## Important:
- Check PROMPT.md first to understand your task
- Check git status/log to see what has already been done
- Work autonomously - make decisions, do not ask questions
- Commit your work regularly with descriptive messages
- ALWAYS run /exit when done (whether complete, blocked, or needing restart)'

# Check for PROMPT.md
if [ ! -f PROMPT.md ]; then
  echo "No PROMPT.md found in current directory."
  echo "Create one with your task description, then run claude-loop again."
  exit 1
fi

# Write runner script (the main loop logic)
RUNNER_SCRIPT="/tmp/claude-loop-runner-$$.sh"
cat > "$RUNNER_SCRIPT" << 'RUNNER_EOF'
#!/bin/bash
STATUS_FILE="$1"
SYSTEM_PROMPT="$2"
ACTIVITY_TIMEOUT="$3"
LOOP_PROMPT="$4"

# Initialize status
cat > "$STATUS_FILE" << EOF
iteration=0
start_time=$(date +%s)
last_activity=$(date +%s)
status=starting
EOF

update_status() {
  sed -i "s/^$1=.*/$1=$2/" "$STATUS_FILE" 2>/dev/null || echo "$1=$2" >> "$STATUS_FILE"
}

iteration=0
while [ -f PROMPT.md ]; do
  ((iteration++))
  update_status "iteration" "$iteration"
  update_status "status" "running"
  update_status "last_activity" "$(date +%s)"

  echo ""
  echo "══════════════════════════════════════════════════════"
  echo "  Iteration $iteration | $(date '+%Y-%m-%d %H:%M:%S')"
  echo "══════════════════════════════════════════════════════"
  echo ""

  marker=$(mktemp)
  touch "$marker"
  no_activity=0

  update_status "status" "claude_running"

  # Activity monitoring in background
  (
    while [ -f "$marker" ]; do
      sleep 30
      if find . -type f -newer "$marker" ! -path './.git/*' 2>/dev/null | grep -q .; then
        touch "$marker"
        update_status "last_activity" "$(date +%s)"
      fi
    done
  ) &
  monitor_pid=$!

  # Run Claude with instruction to read PROMPT.md
  echo "Read PROMPT.md and complete the task. When done, move it to PROMPT.done.md" | IS_SANDBOX=1 claude --dangerously-skip-permissions --system-prompt "$SYSTEM_PROMPT" --append-system-prompt "$LOOP_PROMPT"

  # Cleanup
  rm -f "$marker"
  kill $monitor_pid 2>/dev/null

  if [ -f PROMPT.md ]; then
    update_status "status" "restarting"
    echo ""
    echo "──── Claude exited, restarting in 3s... ────"
    sleep 3
  fi
done

update_status "status" "complete"
echo ""
echo "══════════════════════════════════════════════════════"
echo "  Loop complete! PROMPT.md moved/removed."
[ -f PROMPT.done.md ] && echo "  Results in: PROMPT.done.md"
[ -f PROMPT.blocked.md ] && echo "  Task blocked: PROMPT.blocked.md"
echo "══════════════════════════════════════════════════════"
sleep 30
rm -f "$STATUS_FILE"
RUNNER_EOF
chmod +x "$RUNNER_SCRIPT"

# Check if we're already inside tmux (sandboxer session)
if [ -n "$TMUX" ]; then
  # Inside sandboxer: split current pane, don't create new session

  # Split right for monitor
  tmux split-window -h -l 42 "$MONITOR_SCRIPT '$STATUS_FILE' '$WORKDIR'"

  # Select left pane and run loop
  tmux select-pane -L
  exec "$RUNNER_SCRIPT" "$STATUS_FILE" "$SYSTEM_PROMPT" "$ACTIVITY_TIMEOUT" "$LOOP_PROMPT"
else
  # Standalone: create new tmux session
  SESSION_NAME="claude-loop-$$"

  tmux new-session -d -s "$SESSION_NAME" -c "$WORKDIR"
  tmux send-keys -t "$SESSION_NAME" "$RUNNER_SCRIPT '$STATUS_FILE' '$SYSTEM_PROMPT' '$ACTIVITY_TIMEOUT' '$LOOP_PROMPT'" Enter

  # Split and run monitor
  tmux split-window -t "$SESSION_NAME" -h -l 42
  tmux send-keys -t "$SESSION_NAME" "$MONITOR_SCRIPT '$STATUS_FILE' '$WORKDIR'" Enter

  # Select left pane
  tmux select-pane -t "$SESSION_NAME":0.0

  # Attach
  tmux attach-session -t "$SESSION_NAME"
fi
