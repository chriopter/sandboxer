#!/bin/bash
# claude-loop - Autonomous Claude loop with split-pane monitor

SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"
SYSTEM_PROMPT="$SCRIPT_DIR/system-prompt.txt"
MONITOR_SCRIPT="$SCRIPT_DIR/claude-loop-monitor"
ACTIVITY_TIMEOUT=1800  # 30 minutes in seconds
STATUS_FILE="/tmp/claude-loop-status-$$"
WORKDIR="$(pwd)"

LOOP_PROMPT='You are in AUTONOMOUS LOOP MODE.

A PROMPT.md file exists in your working directory with your task. Work on it.

## Progress tracking (IMPORTANT):
- PROMPT.md contains your task list
- Check off completed items frequently using [x] as you finish them
- This is critical - update PROMPT.md often so progress is visible
- If you hit context limits, you will be restarted with fresh context
- Your checked-off items show the next instance what is already done

## When finished or need fresh context:
- Run /exit to end session - the loop will restart you automatically
- Exit when: all tasks done, context getting long, or need a fresh start
- Do not sit idle - either work or exit

## If you are fully blocked and cannot proceed:
1. Add a "## Blocked" section to PROMPT.md explaining why
2. Run: mv PROMPT.md PROMPT.blocked.md

## Important:
- Check PROMPT.md first to understand your task and see what is already done
- Check git status/log to see previous work
- Work autonomously - make decisions, do not ask questions
- Commit your work regularly with descriptive messages
- Update PROMPT.md checkboxes after each significant step'

# Check for PROMPT.md
if [ ! -f PROMPT.md ]; then
  echo "No PROMPT.md found in current directory."
  echo "Create one with your task description, then run claude-loop again."
  exit 1
fi

# Write runner script (the main loop logic)
RUNNER_SCRIPT="/tmp/claude-loop-runner-$$.sh"
cat > "$RUNNER_SCRIPT" << 'RUNNER_EOF'
#!/bin/bash
STATUS_FILE="$1"
SYSTEM_PROMPT="$2"
ACTIVITY_TIMEOUT="$3"
LOOP_PROMPT="$4"

# Initialize status
cat > "$STATUS_FILE" << EOF
iteration=0
start_time=$(date +%s)
last_activity=$(date +%s)
status=starting
EOF

update_status() {
  sed -i "s/^$1=.*/$1=$2/" "$STATUS_FILE" 2>/dev/null || echo "$1=$2" >> "$STATUS_FILE"
}

iteration=0
while [ -f PROMPT.md ]; do
  ((iteration++))
  update_status "iteration" "$iteration"
  update_status "status" "running"
  update_status "last_activity" "$(date +%s)"

  echo ""
  echo "══════════════════════════════════════════════════════"
  echo "  Iteration $iteration | $(date '+%Y-%m-%d %H:%M:%S')"
  echo "══════════════════════════════════════════════════════"
  echo ""

  marker=$(mktemp)
  touch "$marker"
  no_activity=0

  update_status "status" "claude_running"

  # Run Claude in background so we can monitor and kill if idle
  echo "Read PROMPT.md and work on the tasks. Check off each item with [x] as you complete it." | IS_SANDBOX=1 claude --dangerously-skip-permissions --system-prompt "$SYSTEM_PROMPT" --append-system-prompt "$LOOP_PROMPT" &
  claude_pid=$!

  # Background activity tracker - kills Claude if idle too long
  (
    while kill -0 $claude_pid 2>/dev/null; do
      sleep 30

      # Check for any file changes (excluding .git)
      if find . -type f -newer "$marker" ! -path './.git/*' 2>/dev/null | grep -q .; then
        touch "$marker"
        update_status "last_activity" "$(date +%s)"
      fi

      # Check if idle for too long
      source "$STATUS_FILE"
      now=$(date +%s)
      idle_time=$((now - last_activity))

      if [ $idle_time -ge $ACTIVITY_TIMEOUT ]; then
        update_status "status" "idle_restart"
        echo ""
        echo "──── No activity for 30min, restarting Claude... ────"
        kill $claude_pid 2>/dev/null
        sleep 2
        kill -9 $claude_pid 2>/dev/null
        break
      fi
    done
  ) &
  tracker_pid=$!

  # Wait for Claude to exit (either naturally or killed by tracker)
  wait $claude_pid 2>/dev/null

  # Cleanup
  rm -f "$marker"
  kill $tracker_pid 2>/dev/null

  if [ -f PROMPT.md ]; then
    update_status "status" "restarting"
    echo ""
    echo "──── Claude exited, restarting in 3s... ────"
    sleep 3
  fi
done

update_status "status" "complete"
echo ""
echo "══════════════════════════════════════════════════════"
echo "  Loop stopped - PROMPT.md removed or renamed"
[ -f PROMPT.blocked.md ] && echo "  Task blocked: PROMPT.blocked.md"
echo "  Check PROMPT.md for completed items"
echo "══════════════════════════════════════════════════════"
sleep 30
rm -f "$STATUS_FILE"
RUNNER_EOF
chmod +x "$RUNNER_SCRIPT"

# Check if we're already inside tmux (sandboxer session)
if [ -n "$TMUX" ]; then
  # Inside sandboxer: split current pane, don't create new session

  # Split right for monitor
  tmux split-window -h -l 42 "$MONITOR_SCRIPT '$STATUS_FILE' '$WORKDIR'"

  # Select left pane and run loop
  tmux select-pane -L
  exec "$RUNNER_SCRIPT" "$STATUS_FILE" "$SYSTEM_PROMPT" "$ACTIVITY_TIMEOUT" "$LOOP_PROMPT"
else
  # Standalone: create new tmux session
  SESSION_NAME="claude-loop-$$"

  tmux new-session -d -s "$SESSION_NAME" -c "$WORKDIR"
  tmux send-keys -t "$SESSION_NAME" "$RUNNER_SCRIPT '$STATUS_FILE' '$SYSTEM_PROMPT' '$ACTIVITY_TIMEOUT' '$LOOP_PROMPT'" Enter

  # Split and run monitor
  tmux split-window -t "$SESSION_NAME" -h -l 42
  tmux send-keys -t "$SESSION_NAME" "$MONITOR_SCRIPT '$STATUS_FILE' '$WORKDIR'" Enter

  # Select left pane
  tmux select-pane -t "$SESSION_NAME":0.0

  # Attach
  tmux attach-session -t "$SESSION_NAME"
fi
